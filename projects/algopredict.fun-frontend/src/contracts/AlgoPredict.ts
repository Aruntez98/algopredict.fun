/* eslint-disable */
// @ts-nocheck
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  AppStorageSchema,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "addPrediction(string,string,string,uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "buyShares(uint64,uint8,uint64,pay)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "endPrediction(uint64,uint8)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "claimReward(uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "predictionIndex": {
          "type": "uint64",
          "key": "predictionIndex"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 1
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDggMCAyIDEwCmJ5dGVjYmxvY2sgMHggMHg3MDcyNjU2NDY5NjM3NDY5NmY2ZTQ5NmU2NDY1NzggMHgwMCAweDAwMDAwMDAwMDAwMDAwMDAKCi8vIFRoaXMgVEVBTCB3YXMgZ2VuZXJhdGVkIGJ5IFRFQUxTY3JpcHQgdjAuMTA1LjEKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCnB1c2hpbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCS8vIFRoZSByZXF1ZXN0ZWQgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGNvbnRyYWN0LiBBcmUgeW91IHVzaW5nIHRoZSBjb3JyZWN0IE9uQ29tcGxldGU/IERpZCB5b3Ugc2V0IHlvdXIgYXBwIElEPwoJZXJyCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uOgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbigpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKTogdm9pZApjcmVhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjMzCgkvLyB0aGlzLnByZWRpY3Rpb25JbmRleC52YWx1ZSA9IDAKCWJ5dGVjIDEgLy8gICJwcmVkaWN0aW9uSW5kZXgiCglpbnRjIDIgLy8gMAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gYWRkUHJlZGljdGlvbihzdHJpbmcsc3RyaW5nLHN0cmluZyx1aW50NjQsdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2FkZFByZWRpY3Rpb246CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCXB1c2hieXRlcyAweDE1MWY3Yzc1CgoJLy8gZW5kc0F0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyBzdGFydHNBdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gb3B0aW9uMk5hbWU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyBvcHRpb24xTmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIHF1ZXN0aW9uOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBhZGRQcmVkaWN0aW9uKHN0cmluZyxzdHJpbmcsc3RyaW5nLHVpbnQ2NCx1aW50NjQpdWludDY0CgljYWxsc3ViIGFkZFByZWRpY3Rpb24KCWl0b2IKCWNvbmNhdAoJbG9nCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBhZGRQcmVkaWN0aW9uKHF1ZXN0aW9uOiBzdHJpbmcsIG9wdGlvbjFOYW1lOiBzdHJpbmcsIG9wdGlvbjJOYW1lOiBzdHJpbmcsIHN0YXJ0c0F0OiB1aW50NjQsIGVuZHNBdDogdWludDY0KTogdWludDY0CmFkZFByZWRpY3Rpb246Cglwcm90byA1IDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjM3CgkvLyBhc3NlcnQoc3RhcnRzQXQgPCBlbmRzQXQsICdzdGFydHNBdCBzaG91bGQgYmUgbGVzcyB0aGFuIGVuZHNBdCcpCglmcmFtZV9kaWcgLTQgLy8gc3RhcnRzQXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC01IC8vIGVuZHNBdDogdWludDY0Cgk8CgoJLy8gc3RhcnRzQXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBlbmRzQXQKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjM4CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSB0aGlzLmFwcC5jcmVhdG9yLCAnT25seSBjcmVhdG9yIGNhbiBhZGQgcHJlZGljdGlvbicpCgl0eG4gU2VuZGVyCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCT09CgoJLy8gT25seSBjcmVhdG9yIGNhbiBhZGQgcHJlZGljdGlvbgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MzkKCS8vIG5ld1ByZWRpY3Rpb246IFByZWRpY3Rpb24gPSB7CgkvLyAgICAgICBxdWVzdGlvbjogcXVlc3Rpb24sCgkvLyAgICAgICBvcHRpb24xU2hhcmVzQmhvdWd0aDogMCwKCS8vICAgICAgIG9wdGlvbjJTaGFyZXNCaG91Z3RoOiAwLAoJLy8gICAgICAgb3B0aW9uMTogb3B0aW9uMU5hbWUsCgkvLyAgICAgICBvcHRpb24yOiBvcHRpb24yTmFtZSwKCS8vICAgICAgIHN0YXJ0c0F0OiBzdGFydHNBdCwKCS8vICAgICAgIGVuZHNBdDogZW5kc0F0LAoJLy8gICAgICAgcmVzdWx0OiAwLAoJLy8gICAgIH0KCWJ5dGVjIDAgLy8gIGluaXRpYWwgaGVhZAoJYnl0ZWMgMCAvLyAgaW5pdGlhbCB0YWlsCglwdXNoYnl0ZXMgMHgwMDI3IC8vIGluaXRpYWwgaGVhZCBvZmZzZXQKCWZyYW1lX2RpZyAtMSAvLyBxdWVzdGlvbjogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCWJ5dGVjIDMgLy8gMHgwMDAwMDAwMDAwMDAwMDAwCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglieXRlYyAzIC8vIDB4MDAwMDAwMDAwMDAwMDAwMAoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIC00IC8vIHN0YXJ0c0F0OiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtNSAvLyBlbmRzQXQ6IHVpbnQ2NAoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJYnl0ZWMgMiAvLyAweDAwCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTIgLy8gb3B0aW9uMU5hbWU6IHN0cmluZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTMgLy8gb3B0aW9uMk5hbWU6IHN0cmluZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50Cglwb3AgLy8gcG9wIGhlYWQgb2Zmc2V0Cgljb25jYXQgLy8gY29uY2F0IGhlYWQgYW5kIHRhaWwKCWZyYW1lX2J1cnkgMCAvLyBuZXdQcmVkaWN0aW9uOiBQcmVkaWN0aW9uCgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6NDkKCS8vIHRoaXMucHJlZGljdGlvbnModGhpcy5wcmVkaWN0aW9uSW5kZXgudmFsdWUpLnZhbHVlID0gbmV3UHJlZGljdGlvbgoJYnl0ZWMgMSAvLyAgInByZWRpY3Rpb25JbmRleCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglkdXAKCWJveF9kZWwKCXBvcAoJZnJhbWVfZGlnIDAgLy8gbmV3UHJlZGljdGlvbjogUHJlZGljdGlvbgoJYm94X3B1dAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjUwCgkvLyB0aGlzLnByZWRpY3Rpb25JbmRleC52YWx1ZSA9IHRoaXMucHJlZGljdGlvbkluZGV4LnZhbHVlICsgMQoJYnl0ZWMgMSAvLyAgInByZWRpY3Rpb25JbmRleCIKCWR1cAoJYXBwX2dsb2JhbF9nZXQKCWludGMgMCAvLyAxCgkrCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjUxCgkvLyByZXR1cm4gdGhpcy5wcmVkaWN0aW9uSW5kZXgudmFsdWUgLSAxOwoJYnl0ZWMgMSAvLyAgInByZWRpY3Rpb25JbmRleCIKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDAgLy8gMQoJLQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBidXlTaGFyZXModWludDY0LHVpbnQ4LHVpbnQ2NCxwYXkpdm9pZAoqYWJpX3JvdXRlX2J1eVNoYXJlczoKCS8vIHBheVR4bjogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50YyAwIC8vIDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludGMgMCAvLyAgcGF5Cgk9PQoKCS8vIGFyZ3VtZW50IDAgKHBheVR4bikgZm9yIGJ1eVNoYXJlcyBtdXN0IGJlIGEgcGF5IHRyYW5zYWN0aW9uCglhc3NlcnQKCgkvLyBhbW91bnQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIG9wdGlvbjogdWludDgKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDAgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAyIChvcHRpb24pIGZvciBidXlTaGFyZXMgbXVzdCBiZSBhIHVpbnQ4Cglhc3NlcnQKCWJ0b2kKCgkvLyBwcmVkaWN0aW9uSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgYnV5U2hhcmVzKHVpbnQ2NCx1aW50OCx1aW50NjQscGF5KXZvaWQKCWNhbGxzdWIgYnV5U2hhcmVzCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBidXlTaGFyZXMocHJlZGljdGlvbklkOiB1aW50NjQsIG9wdGlvbjogdWludDgsIGFtb3VudDogdWludDY0LCBwYXlUeG46IFBheVR4bik6IHZvaWQKYnV5U2hhcmVzOgoJcHJvdG8gNCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gNwoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjU1CgkvLyBhc3NlcnQodGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLmV4aXN0cywgJ1ByZWRpY3Rpb24gZG9lcyBub3QgZXhpc3QnKQoJZnJhbWVfZGlnIC0xIC8vIHByZWRpY3Rpb25JZDogdWludDY0CglpdG9iCglib3hfbGVuCglzd2FwCglwb3AKCgkvLyBQcmVkaWN0aW9uIGRvZXMgbm90IGV4aXN0Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo1NgoJLy8gcHJlZGljdGlvbiA9IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJZnJhbWVfZGlnIC0xIC8vIHByZWRpY3Rpb25JZDogdWludDY0CglpdG9iCglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo1NwoJLy8gYXNzZXJ0KGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wID49IHByZWRpY3Rpb24uc3RhcnRzQXQsICdQcmVkaWN0aW9uIGhhcyBub3Qgc3RhcnRlZCB5ZXQnKQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAxOCA4CglidG9pCgk+PQoKCS8vIFByZWRpY3Rpb24gaGFzIG5vdCBzdGFydGVkIHlldAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6NTgKCS8vIGFzc2VydChnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCA8IHByZWRpY3Rpb24uZW5kc0F0LCAnUHJlZGljdGlvbiBoYXMgZW5kZWQnKQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAyNiA4CglidG9pCgk8CgoJLy8gUHJlZGljdGlvbiBoYXMgZW5kZWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjU5CgkvLyBhc3NlcnQob3B0aW9uID09PSAxIHx8IG9wdGlvbiA9PT0gMiwgJ0ludmFsaWQgb3B0aW9uJykKCWZyYW1lX2RpZyAtMiAvLyBvcHRpb246IHVpbnQ4CglpbnRjIDAgLy8gMQoJPT0KCWR1cAoJYm56ICpza2lwX29yMAoJZnJhbWVfZGlnIC0yIC8vIG9wdGlvbjogdWludDgKCWludGMgMyAvLyAyCgk9PQoJfHwKCipza2lwX29yMDoKCS8vIEludmFsaWQgb3B0aW9uCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo2MAoJLy8gYXNzZXJ0KHByZWRpY3Rpb24ucmVzdWx0ID09PSAwLCAnUHJlZGljdGlvbiByZXN1bHQgaXMgYWxyZWFkeSBzZXQnKQoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAzNCAxCglidG9pCglpbnRjIDIgLy8gMAoJPT0KCgkvLyBQcmVkaWN0aW9uIHJlc3VsdCBpcyBhbHJlYWR5IHNldAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6NjEKCS8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5ID0geyB1c2VyOiB0aGlzLnR4bi5zZW5kZXIsIHByZWRpY3Rpb25JZDogcHJlZGljdGlvbklkIH0KCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBwcmVkaWN0aW9uSWQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo2MgoJLy8gaGFzVXNlckJ1eWVkUHJldmlvdXNseSA9IHRoaXMudXNlclByZWRpY3Rpb25zKHByZWRpY3Rpb25LZXkpLmV4aXN0cwoJZnJhbWVfZGlnIDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCWJveF9sZW4KCXN3YXAKCXBvcAoJZnJhbWVfYnVyeSAyIC8vIGhhc1VzZXJCdXllZFByZXZpb3VzbHk6IGJvb2wKCgkvLyAqaWYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6NjMKCS8vIGhhc1VzZXJCdXllZFByZXZpb3VzbHkKCWZyYW1lX2RpZyAyIC8vIGhhc1VzZXJCdXllZFByZXZpb3VzbHk6IGJvb2wKCWJ6ICppZjBfZWxzZQoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6NjQKCS8vIHByZXZpb3VzU2hhcmVzID0gdGhpcy51c2VyUHJlZGljdGlvbnMocHJlZGljdGlvbktleSkudmFsdWUKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglmcmFtZV9idXJ5IDMgLy8gc3RvcmFnZSBrZXkvL3ByZXZpb3VzU2hhcmVzCgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjY1CgkvLyBwcmV2aW91c1NoYXJlcy5vcHRpb24gPT09IG9wdGlvbgoJZnJhbWVfZGlnIDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCWludGMgMiAvLyAwCglpbnRjIDAgLy8gMQoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBvcHRpb246IHVpbnQ4Cgk9PQoJYnogKmlmMV9lbHNlaWYxX2NvbmRpdGlvbgoKCS8vICppZjFfY29uc2VxdWVudAoJLy8gKmlmMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjY2CgkvLyBwcmV2aW91c1NoYXJlcy5hbW91bnQgPiBhbW91bnQKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglpbnRjIDAgLy8gIGhlYWRPZmZzZXQKCWludGMgMSAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudDogdWludDY0Cgk+CglieiAqaWYyX2Vsc2UKCgkvLyAqaWYyX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjY3CgkvLyBkaWZmID0gcHJldmlvdXNTaGFyZXMuYW1vdW50IC0gYW1vdW50CglmcmFtZV9kaWcgMSAvLyBwcmVkaWN0aW9uS2V5OiBVc2VyUHJlZGljdGlvbktleQoJaW50YyAwIC8vICBoZWFkT2Zmc2V0CglpbnRjIDEgLy8gOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSA0IC8vIGRpZmY6IHVpbnQ2NAoKCS8vICppZjNfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo2OAoJLy8gb3B0aW9uID09PSAxCglmcmFtZV9kaWcgLTIgLy8gb3B0aW9uOiB1aW50OAoJaW50YyAwIC8vIDEKCT09CglieiAqaWYzX2Vsc2UKCgkvLyAqaWYzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjY5CgkvLyBwcmVkaWN0aW9uLm9wdGlvbjFTaGFyZXNCaG91Z3RoID0gcHJlZGljdGlvbi5vcHRpb24xU2hhcmVzQmhvdWd0aCAtIGRpZmYKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnByZWRpY3Rpb25zKHByZWRpY3Rpb25JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMyAvLyAyCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDIgOAoJYnRvaQoJZnJhbWVfZGlnIDQgLy8gZGlmZjogdWludDY0CgktCglpdG9iCglyZXBsYWNlMwoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglib3hfcHV0CgliICppZjNfZW5kCgoqaWYzX2Vsc2U6CgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo3MQoJLy8gcHJlZGljdGlvbi5vcHRpb24yU2hhcmVzQmhvdWd0aCA9IHByZWRpY3Rpb24ub3B0aW9uMlNoYXJlc0Job3VndGggLSBkaWZmCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDQgLy8gMTAKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnByZWRpY3Rpb25zKHByZWRpY3Rpb25JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMTAgOAoJYnRvaQoJZnJhbWVfZGlnIDQgLy8gZGlmZjogdWludDY0CgktCglpdG9iCglyZXBsYWNlMwoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglib3hfcHV0CgoqaWYzX2VuZDoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjczCgkvLyBzZW5kUGF5bWVudCh7IGFtb3VudDogZGlmZiwgcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlciB9KQoJaXR4bl9iZWdpbgoJaW50YyAwIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo3MwoJLy8gYW1vdW50OiBkaWZmCglmcmFtZV9kaWcgNCAvLyBkaWZmOiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6NzMKCS8vIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIKCXR4biBTZW5kZXIKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnRjIDIgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgliICppZjJfZW5kCgoqaWYyX2Vsc2U6CgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo3NQoJLy8gZGlmZiA9IGFtb3VudCAtIHByZXZpb3VzU2hhcmVzLmFtb3VudAoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudDogdWludDY0CglmcmFtZV9kaWcgMSAvLyBwcmVkaWN0aW9uS2V5OiBVc2VyUHJlZGljdGlvbktleQoJaW50YyAwIC8vICBoZWFkT2Zmc2V0CglpbnRjIDEgLy8gOAoJYm94X2V4dHJhY3QKCWJ0b2kKCS0KCWZyYW1lX2J1cnkgNSAvLyBkaWZmOiB1aW50NjQKCgkvLyAqaWY0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6NzYKCS8vIG9wdGlvbiA9PT0gMQoJZnJhbWVfZGlnIC0yIC8vIG9wdGlvbjogdWludDgKCWludGMgMCAvLyAxCgk9PQoJYnogKmlmNF9lbHNlCgoJLy8gKmlmNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo3NwoJLy8gcHJlZGljdGlvbi5vcHRpb24xU2hhcmVzQmhvdWd0aCA9IHByZWRpY3Rpb24ub3B0aW9uMVNoYXJlc0Job3VndGggKyBkaWZmCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDMgLy8gMgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAyIDgKCWJ0b2kKCWZyYW1lX2RpZyA1IC8vIGRpZmY6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoJYiAqaWY0X2VuZAoKKmlmNF9lbHNlOgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6NzkKCS8vIHByZWRpY3Rpb24ub3B0aW9uMlNoYXJlc0Job3VndGggPSBwcmVkaWN0aW9uLm9wdGlvbjJTaGFyZXNCaG91Z3RoICsgZGlmZgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyA0IC8vIDEwCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDEwIDgKCWJ0b2kKCWZyYW1lX2RpZyA1IC8vIGRpZmY6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoKKmlmNF9lbmQ6CgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo4MQoJLy8gdmVyaWZ5UGF5VHhuKHBheVR4biwgeyByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywgYW1vdW50OiB7IGdyZWF0ZXJUaGFuRXF1YWxUbzogZGlmZiB9IH0pCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtNCAvLyBwYXlUeG46IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicGF5VHhuIiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTQgLy8gcGF5VHhuOiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIDUgLy8gZGlmZjogdWludDY0Cgk+PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicGF5VHhuIiwiZmllbGQiOiJhbW91bnQiLCJjb25kaXRpb24iOiJncmVhdGVyVGhhbkVxdWFsVG8iLCJleHBlY3RlZCI6Ij49ZGlmZiJ9Cglhc3NlcnQKCippZjJfZW5kOgoJYiAqaWYxX2VuZAoKKmlmMV9lbHNlaWYxX2NvbmRpdGlvbjoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjgzCgkvLyBwcmV2aW91c1NoYXJlcy5hbW91bnQgPiBhbW91bnQKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglpbnRjIDAgLy8gIGhlYWRPZmZzZXQKCWludGMgMSAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudDogdWludDY0Cgk+CglieiAqaWYxX2Vsc2UKCgkvLyAqaWYxX2Vsc2VpZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6ODQKCS8vIGRpZmYgPSBwcmV2aW91c1NoYXJlcy5hbW91bnQgLSBhbW91bnQKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglpbnRjIDAgLy8gIGhlYWRPZmZzZXQKCWludGMgMSAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudDogdWludDY0CgktCglmcmFtZV9idXJ5IDYgLy8gZGlmZjogdWludDY0CgoJLy8gKmlmNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjg1CgkvLyBvcHRpb24gPT09IDEKCWZyYW1lX2RpZyAtMiAvLyBvcHRpb246IHVpbnQ4CglpbnRjIDAgLy8gMQoJPT0KCWJ6ICppZjVfZWxzZQoKCS8vICppZjVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6ODYKCS8vIHByZWRpY3Rpb24ub3B0aW9uMVNoYXJlc0Job3VndGggPSBwcmVkaWN0aW9uLm9wdGlvbjFTaGFyZXNCaG91Z3RoICsgYW1vdW50CglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDMgLy8gMgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAyIDgKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjg3CgkvLyBwcmVkaWN0aW9uLm9wdGlvbjJTaGFyZXNCaG91Z3RoID0gcHJlZGljdGlvbi5vcHRpb24yU2hhcmVzQmhvdWd0aCAtIHByZXZpb3VzU2hhcmVzLmFtb3VudAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyA0IC8vIDEwCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDEwIDgKCWJ0b2kKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglpbnRjIDAgLy8gIGhlYWRPZmZzZXQKCWludGMgMSAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJLQoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoJYiAqaWY1X2VuZAoKKmlmNV9lbHNlOgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6ODkKCS8vIHByZWRpY3Rpb24ub3B0aW9uMlNoYXJlc0Job3VndGggPSBwcmVkaWN0aW9uLm9wdGlvbjJTaGFyZXNCaG91Z3RoICsgYW1vdW50CglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDQgLy8gMTAKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnByZWRpY3Rpb25zKHByZWRpY3Rpb25JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMTAgOAoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudDogdWludDY0CgkrCglpdG9iCglyZXBsYWNlMwoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglib3hfcHV0CgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6OTAKCS8vIHByZWRpY3Rpb24ub3B0aW9uMVNoYXJlc0Job3VndGggPSBwcmVkaWN0aW9uLm9wdGlvbjFTaGFyZXNCaG91Z3RoIC0gcHJldmlvdXNTaGFyZXMuYW1vdW50CglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDMgLy8gMgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAyIDgKCWJ0b2kKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglpbnRjIDAgLy8gIGhlYWRPZmZzZXQKCWludGMgMSAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJLQoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoKKmlmNV9lbmQ6CgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czo5MgoJLy8gc2VuZFBheW1lbnQoeyBhbW91bnQ6IGRpZmYsIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIgfSkKCWl0eG5fYmVnaW4KCWludGMgMCAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6OTIKCS8vIGFtb3VudDogZGlmZgoJZnJhbWVfZGlnIDYgLy8gZGlmZjogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjkyCgkvLyByZWNlaXZlcjogdGhpcy50eG4uc2VuZGVyCgl0eG4gU2VuZGVyCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50YyAyIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJYiAqaWYxX2VuZAoKKmlmMV9lbHNlOgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6OTQKCS8vIGRpZmYgPSBhbW91bnQgLSBwcmV2aW91c1NoYXJlcy5hbW91bnQKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCWludGMgMCAvLyAgaGVhZE9mZnNldAoJaW50YyAxIC8vIDgKCWJveF9leHRyYWN0CglidG9pCgktCglmcmFtZV9idXJ5IDcgLy8gZGlmZjogdWludDY0CgoJLy8gKmlmNl9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjk1CgkvLyBvcHRpb24gPT09IDEKCWZyYW1lX2RpZyAtMiAvLyBvcHRpb246IHVpbnQ4CglpbnRjIDAgLy8gMQoJPT0KCWJ6ICppZjZfZWxzZQoKCS8vICppZjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6OTYKCS8vIHByZWRpY3Rpb24ub3B0aW9uMVNoYXJlc0Job3VndGggPSBwcmVkaWN0aW9uLm9wdGlvbjFTaGFyZXNCaG91Z3RoICsgYW1vdW50CglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDMgLy8gMgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAyIDgKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjk3CgkvLyBwcmVkaWN0aW9uLm9wdGlvbjJTaGFyZXNCaG91Z3RoID0gcHJlZGljdGlvbi5vcHRpb24yU2hhcmVzQmhvdWd0aCAtIHByZXZpb3VzU2hhcmVzLmFtb3VudAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyA0IC8vIDEwCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDEwIDgKCWJ0b2kKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglpbnRjIDAgLy8gIGhlYWRPZmZzZXQKCWludGMgMSAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJLQoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoJYiAqaWY2X2VuZAoKKmlmNl9lbHNlOgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6OTkKCS8vIHByZWRpY3Rpb24ub3B0aW9uMlNoYXJlc0Job3VndGggPSBwcmVkaWN0aW9uLm9wdGlvbjJTaGFyZXNCaG91Z3RoICsgYW1vdW50CglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDQgLy8gMTAKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnByZWRpY3Rpb25zKHByZWRpY3Rpb25JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMTAgOAoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudDogdWludDY0CgkrCglpdG9iCglyZXBsYWNlMwoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglib3hfcHV0CgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTAwCgkvLyBwcmVkaWN0aW9uLm9wdGlvbjFTaGFyZXNCaG91Z3RoID0gcHJlZGljdGlvbi5vcHRpb24xU2hhcmVzQmhvdWd0aCAtIHByZXZpb3VzU2hhcmVzLmFtb3VudAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAzIC8vIDIKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnByZWRpY3Rpb25zKHByZWRpY3Rpb25JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMiA4CglidG9pCglmcmFtZV9kaWcgMSAvLyBwcmVkaWN0aW9uS2V5OiBVc2VyUHJlZGljdGlvbktleQoJaW50YyAwIC8vICBoZWFkT2Zmc2V0CglpbnRjIDEgLy8gOAoJYm94X2V4dHJhY3QKCWJ0b2kKCS0KCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJZHVwCglib3hfZGVsCglwb3AKCXN3YXAKCWJveF9wdXQKCippZjZfZW5kOgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTAyCgkvLyB2ZXJpZnlQYXlUeG4ocGF5VHhuLCB7IHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLCBhbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiBkaWZmIH0gfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC00IC8vIHBheVR4bjogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJwYXlUeG4iLCJmaWVsZCI6InJlY2VpdmVyIiwiZXhwZWN0ZWQiOiJ0aGlzLmFwcC5hZGRyZXNzIn0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtNCAvLyBwYXlUeG46IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgNyAvLyBkaWZmOiB1aW50NjQKCT49CgoJLy8gdHJhbnNhY3Rpb24gdmVyaWZpY2F0aW9uIGZhaWxlZDogeyJ0eG4iOiJwYXlUeG4iLCJmaWVsZCI6ImFtb3VudCIsImNvbmRpdGlvbiI6ImdyZWF0ZXJUaGFuRXF1YWxUbyIsImV4cGVjdGVkIjoiPj1kaWZmIn0KCWFzc2VydAoKKmlmMV9lbmQ6CgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxMDQKCS8vIHRoaXMudXNlclByZWRpY3Rpb25zKHByZWRpY3Rpb25LZXkpLnZhbHVlID0gewoJLy8gICAgICAgICBvcHRpb246IG9wdGlvbiwKCS8vICAgICAgICAgYW1vdW50OiBhbW91bnQsCgkvLyAgICAgICAgIGNsYWltZWQ6IDAsCgkvLyAgICAgICB9CglmcmFtZV9kaWcgMSAvLyBwcmVkaWN0aW9uS2V5OiBVc2VyUHJlZGljdGlvbktleQoJZnJhbWVfZGlnIC0yIC8vIG9wdGlvbjogdWludDgKCWl0b2IKCWV4dHJhY3QgNyAxCglmcmFtZV9kaWcgLTMgLy8gYW1vdW50OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJYnl0ZWMgMiAvLyAweDAwCgljb25jYXQKCWJveF9wdXQKCWIgKmlmMF9lbmQKCippZjBfZWxzZToKCS8vICppZjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxMTAKCS8vIG9wdGlvbiA9PT0gMQoJZnJhbWVfZGlnIC0yIC8vIG9wdGlvbjogdWludDgKCWludGMgMCAvLyAxCgk9PQoJYnogKmlmN19lbHNlCgoJLy8gKmlmN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxMTEKCS8vIHByZWRpY3Rpb24ub3B0aW9uMVNoYXJlc0Job3VndGggPSBwcmVkaWN0aW9uLm9wdGlvbjFTaGFyZXNCaG91Z3RoICsgYW1vdW50CglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDMgLy8gMgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAyIDgKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoJYiAqaWY3X2VuZAoKKmlmN19lbHNlOgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTEzCgkvLyBwcmVkaWN0aW9uLm9wdGlvbjJTaGFyZXNCaG91Z3RoID0gcHJlZGljdGlvbi5vcHRpb24yU2hhcmVzQmhvdWd0aCArIGFtb3VudAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyA0IC8vIDEwCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDEwIDgKCWJ0b2kKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoKKmlmN19lbmQ6CgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxMTUKCS8vIHZlcmlmeVBheVR4bihwYXlUeG4sIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsIGFtb3VudDogeyBncmVhdGVyVGhhbkVxdWFsVG86IGFtb3VudCB9IH0pCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtNCAvLyBwYXlUeG46IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicGF5VHhuIiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTQgLy8gcGF5VHhuOiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIC0zIC8vIGFtb3VudDogdWludDY0Cgk+PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoicGF5VHhuIiwiZmllbGQiOiJhbW91bnQiLCJjb25kaXRpb24iOiJncmVhdGVyVGhhbkVxdWFsVG8iLCJleHBlY3RlZCI6Ij49YW1vdW50In0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjExNgoJLy8gdGhpcy51c2VyUHJlZGljdGlvbnMocHJlZGljdGlvbktleSkudmFsdWUgPSB7CgkvLyAgICAgICAgIG9wdGlvbjogb3B0aW9uLAoJLy8gICAgICAgICBhbW91bnQ6IGFtb3VudCwKCS8vICAgICAgICAgY2xhaW1lZDogMCwKCS8vICAgICAgIH0KCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglmcmFtZV9kaWcgLTIgLy8gb3B0aW9uOiB1aW50OAoJaXRvYgoJZXh0cmFjdCA3IDEKCWZyYW1lX2RpZyAtMyAvLyBhbW91bnQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglieXRlYyAyIC8vIDB4MDAKCWNvbmNhdAoJYm94X3B1dAoKKmlmMF9lbmQ6CglyZXRzdWIKCi8vIGVuZFByZWRpY3Rpb24odWludDY0LHVpbnQ4KXZvaWQKKmFiaV9yb3V0ZV9lbmRQcmVkaWN0aW9uOgoJLy8gcmVzdWx0OiB1aW50OAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMCAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDAgKHJlc3VsdCkgZm9yIGVuZFByZWRpY3Rpb24gbXVzdCBiZSBhIHVpbnQ4Cglhc3NlcnQKCWJ0b2kKCgkvLyBwcmVkaWN0aW9uSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgZW5kUHJlZGljdGlvbih1aW50NjQsdWludDgpdm9pZAoJY2FsbHN1YiBlbmRQcmVkaWN0aW9uCglpbnRjIDAgLy8gMQoJcmV0dXJuCgovLyBlbmRQcmVkaWN0aW9uKHByZWRpY3Rpb25JZDogdWludDY0LCByZXN1bHQ6IHVpbnQ4KTogdm9pZAplbmRQcmVkaWN0aW9uOgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxMjUKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMuYXBwLmNyZWF0b3IsICdPbmx5IGNyZWF0b3IgY2FuIGVuZCBwcmVkaWN0aW9uJykKCXR4biBTZW5kZXIKCXR4bmEgQXBwbGljYXRpb25zIDAKCWFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKCXBvcAoJPT0KCgkvLyBPbmx5IGNyZWF0b3IgY2FuIGVuZCBwcmVkaWN0aW9uCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxMjYKCS8vIGFzc2VydCh0aGlzLnByZWRpY3Rpb25zKHByZWRpY3Rpb25JZCkuZXhpc3RzLCAnUHJlZGljdGlvbiBkb2VzIG5vdCBleGlzdCcpCglmcmFtZV9kaWcgLTEgLy8gcHJlZGljdGlvbklkOiB1aW50NjQKCWl0b2IKCWJveF9sZW4KCXN3YXAKCXBvcAoKCS8vIFByZWRpY3Rpb24gZG9lcyBub3QgZXhpc3QKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjEyNwoJLy8gcHJlZGljdGlvbiA9IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJZnJhbWVfZGlnIC0xIC8vIHByZWRpY3Rpb25JZDogdWludDY0CglpdG9iCglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxMjgKCS8vIGFzc2VydChnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCA+PSBwcmVkaWN0aW9uLmVuZHNBdCwgJ1ByZWRpY3Rpb24gaGFzIG5vdCBlbmRlZCB5ZXQnKQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAyNiA4CglidG9pCgk+PQoKCS8vIFByZWRpY3Rpb24gaGFzIG5vdCBlbmRlZCB5ZXQKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjEyOQoJLy8gYXNzZXJ0KHByZWRpY3Rpb24ucmVzdWx0ID09PSAwLCAnUHJlZGljdGlvbiByZXN1bHQgaXMgYWxyZWFkeSBzZXQnKQoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAzNCAxCglidG9pCglpbnRjIDIgLy8gMAoJPT0KCgkvLyBQcmVkaWN0aW9uIHJlc3VsdCBpcyBhbHJlYWR5IHNldAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTMwCgkvLyBwcmVkaWN0aW9uLnJlc3VsdCA9IHJlc3VsdAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJcHVzaGludCAzNAoJZnJhbWVfZGlnIC0yIC8vIHJlc3VsdDogdWludDgKCWl0b2IKCWV4dHJhY3QgNyAxCglyZXBsYWNlMwoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglib3hfcHV0CglyZXRzdWIKCi8vIGNsYWltUmV3YXJkKHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfY2xhaW1SZXdhcmQ6CgkvLyBwcmVkaWN0aW9uSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgY2xhaW1SZXdhcmQodWludDY0KXZvaWQKCWNhbGxzdWIgY2xhaW1SZXdhcmQKCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGNsYWltUmV3YXJkKHByZWRpY3Rpb25JZDogdWludDY0KTogdm9pZApjbGFpbVJld2FyZDoKCXByb3RvIDEgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDQKCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxMzQKCS8vIGFzc2VydCh0aGlzLnByZWRpY3Rpb25zKHByZWRpY3Rpb25JZCkuZXhpc3RzLCAnUHJlZGljdGlvbiBkb2VzIG5vdCBleGlzdCcpCglmcmFtZV9kaWcgLTEgLy8gcHJlZGljdGlvbklkOiB1aW50NjQKCWl0b2IKCWJveF9sZW4KCXN3YXAKCXBvcAoKCS8vIFByZWRpY3Rpb24gZG9lcyBub3QgZXhpc3QKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjEzNQoJLy8gcHJlZGljdGlvbiA9IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJZnJhbWVfZGlnIC0xIC8vIHByZWRpY3Rpb25JZDogdWludDY0CglpdG9iCglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxMzYKCS8vIGFzc2VydChnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCA+PSBwcmVkaWN0aW9uLmVuZHNBdCwgJ1ByZWRpY3Rpb24gaGFzIG5vdCBlbmRlZCB5ZXQnKQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAyNiA4CglidG9pCgk+PQoKCS8vIFByZWRpY3Rpb24gaGFzIG5vdCBlbmRlZCB5ZXQKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjEzNwoJLy8gYXNzZXJ0KHByZWRpY3Rpb24ucmVzdWx0ICE9PSAwLCAnUHJlZGljdGlvbiByZXN1bHQgaXMgbm90IHNldCB5ZXQnKQoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAzNCAxCglidG9pCglpbnRjIDIgLy8gMAoJIT0KCgkvLyBQcmVkaWN0aW9uIHJlc3VsdCBpcyBub3Qgc2V0IHlldAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTM4CgkvLyBwcmVkaWN0aW9uS2V5OiBVc2VyUHJlZGljdGlvbktleSA9IHsgdXNlcjogdGhpcy50eG4uc2VuZGVyLCBwcmVkaWN0aW9uSWQ6IHByZWRpY3Rpb25JZCB9Cgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gcHJlZGljdGlvbklkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTM5CgkvLyBhc3NlcnQodGhpcy51c2VyUHJlZGljdGlvbnMocHJlZGljdGlvbktleSkuZXhpc3RzLCAnVXNlciBoYXMgbm90IGJvdWdodCBzaGFyZXMnKQoJZnJhbWVfZGlnIDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCWJveF9sZW4KCXN3YXAKCXBvcAoKCS8vIFVzZXIgaGFzIG5vdCBib3VnaHQgc2hhcmVzCglhc3NlcnQKCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxNDAKCS8vIHVzZXJQcmVkaWN0aW9uID0gdGhpcy51c2VyUHJlZGljdGlvbnMocHJlZGljdGlvbktleSkudmFsdWUKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglmcmFtZV9idXJ5IDIgLy8gc3RvcmFnZSBrZXkvL3VzZXJQcmVkaWN0aW9uCgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTQxCgkvLyBhc3NlcnQodXNlclByZWRpY3Rpb24uY2xhaW1lZCA9PT0gMCwgJ1VzZXIgaGFzIGFscmVhZHkgY2xhaW1lZCByZXdhcmQnKQoJZnJhbWVfZGlnIDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCXB1c2hpbnQgOSAvLyBoZWFkT2Zmc2V0CglpbnRjIDAgLy8gMQoJYm94X2V4dHJhY3QKCWJ0b2kKCWludGMgMiAvLyAwCgk9PQoKCS8vIFVzZXIgaGFzIGFscmVhZHkgY2xhaW1lZCByZXdhcmQKCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjE0MgoJLy8gdG90YWxTaGFyZXMgPSBwcmVkaWN0aW9uLm9wdGlvbjFTaGFyZXNCaG91Z3RoICsgcHJlZGljdGlvbi5vcHRpb24yU2hhcmVzQmhvdWd0aAoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAyIDgKCWJ0b2kKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnByZWRpY3Rpb25zKHByZWRpY3Rpb25JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMTAgOAoJYnRvaQoJKwoJZnJhbWVfYnVyeSAzIC8vIHRvdGFsU2hhcmVzOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxNDMKCS8vIHJld2FyZCA9IDEgKiB1c2VyUHJlZGljdGlvbi5hbW91bnQKCWludGMgMCAvLyAxCglmcmFtZV9kaWcgMSAvLyBwcmVkaWN0aW9uS2V5OiBVc2VyUHJlZGljdGlvbktleQoJaW50YyAwIC8vICBoZWFkT2Zmc2V0CglpbnRjIDEgLy8gOAoJYm94X2V4dHJhY3QKCWJ0b2kKCSoKCWZyYW1lX2J1cnkgNCAvLyByZXdhcmQ6IHVpbnQ2NAoKCS8vICppZjhfY29uZGl0aW9uCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxNDQKCS8vIHByZWRpY3Rpb24ucmVzdWx0ID09PSAxCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDM0IDEKCWJ0b2kKCWludGMgMCAvLyAxCgk9PQoJYnogKmlmOF9lbHNlaWYxX2NvbmRpdGlvbgoKCS8vICppZjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTQ1CgkvLyByZXdhcmQgPSAodG90YWxTaGFyZXMgKiB1c2VyUHJlZGljdGlvbi5hbW91bnQpIC8gcHJlZGljdGlvbi5vcHRpb24xU2hhcmVzQmhvdWd0aAoJZnJhbWVfZGlnIDMgLy8gdG90YWxTaGFyZXM6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCWludGMgMCAvLyAgaGVhZE9mZnNldAoJaW50YyAxIC8vIDgKCWJveF9leHRyYWN0CglidG9pCgkqCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vcHJlZGljdGlvbgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wcmVkaWN0aW9ucyhwcmVkaWN0aW9uSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDIgOAoJYnRvaQoJLwoJZnJhbWVfYnVyeSA0IC8vIHJld2FyZDogdWludDY0CgliICppZjhfZW5kCgoqaWY4X2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTQ2CgkvLyBwcmVkaWN0aW9uLnJlc3VsdCA9PT0gMgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAzNCAxCglidG9pCglpbnRjIDMgLy8gMgoJPT0KCWJ6ICppZjhfZW5kCgoJLy8gKmlmOF9lbHNlaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjE0NwoJLy8gcmV3YXJkID0gKHRvdGFsU2hhcmVzICogdXNlclByZWRpY3Rpb24uYW1vdW50KSAvIHByZWRpY3Rpb24ub3B0aW9uMlNoYXJlc0Job3VndGgKCWZyYW1lX2RpZyAzIC8vIHRvdGFsU2hhcmVzOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglpbnRjIDAgLy8gIGhlYWRPZmZzZXQKCWludGMgMSAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJKgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAxMCA4CglidG9pCgkvCglmcmFtZV9idXJ5IDQgLy8gcmV3YXJkOiB1aW50NjQKCippZjhfZW5kOgoJLy8gKmlmOV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjE0OQoJLy8gcHJlZGljdGlvbi5yZXN1bHQgIT09IDMgJiYgcHJlZGljdGlvbi5yZXN1bHQgIT09IHVzZXJQcmVkaWN0aW9uLm9wdGlvbgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3ByZWRpY3Rpb24KCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucHJlZGljdGlvbnMocHJlZGljdGlvbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAzNCAxCglidG9pCglwdXNoaW50IDMKCSE9CglkdXAKCWJ6ICpza2lwX2FuZDAKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly9wcmVkaWN0aW9uCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnByZWRpY3Rpb25zKHByZWRpY3Rpb25JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMzQgMQoJYnRvaQoJZnJhbWVfZGlnIDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCWludGMgMiAvLyAwCglpbnRjIDAgLy8gMQoJYm94X2V4dHJhY3QKCWJ0b2kKCSE9CgkmJgoKKnNraXBfYW5kMDoKCWJ6ICppZjlfZW5kCgoJLy8gKmlmOV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxNTAKCS8vIHJld2FyZCA9IDAKCWludGMgMiAvLyAwCglmcmFtZV9idXJ5IDQgLy8gcmV3YXJkOiB1aW50NjQKCippZjlfZW5kOgoJLy8gY29udHJhY3RzXEFsZ29QcmVkaWN0LmFsZ28udHM6MTUyCgkvLyBzZW5kUGF5bWVudCh7IGFtb3VudDogcmV3YXJkLCByZWNlaXZlcjogdGhpcy50eG4uc2VuZGVyIH0pCglpdHhuX2JlZ2luCglpbnRjIDAgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjE1MgoJLy8gYW1vdW50OiByZXdhcmQKCWZyYW1lX2RpZyA0IC8vIHJld2FyZDogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0c1xBbGdvUHJlZGljdC5hbGdvLnRzOjE1MgoJLy8gcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludGMgMiAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHNcQWxnb1ByZWRpY3QuYWxnby50czoxNTMKCS8vIHRoaXMudXNlclByZWRpY3Rpb25zKHByZWRpY3Rpb25LZXkpLnZhbHVlID0gewoJLy8gICAgICAgb3B0aW9uOiB1c2VyUHJlZGljdGlvbi5vcHRpb24sCgkvLyAgICAgICBhbW91bnQ6IHVzZXJQcmVkaWN0aW9uLmFtb3VudCwKCS8vICAgICAgIGNsYWltZWQ6IDEsCgkvLyAgICAgfQoJZnJhbWVfZGlnIDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCWZyYW1lX2RpZyAxIC8vIHByZWRpY3Rpb25LZXk6IFVzZXJQcmVkaWN0aW9uS2V5CglpbnRjIDIgLy8gMAoJaW50YyAwIC8vIDEKCWJveF9leHRyYWN0CglidG9pCglpdG9iCglleHRyYWN0IDcgMQoJZnJhbWVfZGlnIDEgLy8gcHJlZGljdGlvbktleTogVXNlclByZWRpY3Rpb25LZXkKCWludGMgMCAvLyAgaGVhZE9mZnNldAoJaW50YyAxIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglpdG9iCgljb25jYXQKCXB1c2hieXRlcyAweDAxCgljb25jYXQKCWJveF9wdXQKCXJldHN1YgoKKmNyZWF0ZV9Ob09wOgoJcHVzaGJ5dGVzIDB4Yjg0NDdiMzYgLy8gbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY3JlYXRlIE5vT3AKCWVycgoKKmNhbGxfTm9PcDoKCXB1c2hieXRlcyAweDcxY2Q5ZGRjIC8vIG1ldGhvZCAiYWRkUHJlZGljdGlvbihzdHJpbmcsc3RyaW5nLHN0cmluZyx1aW50NjQsdWludDY0KXVpbnQ2NCIKCXB1c2hieXRlcyAweGVkN2Y5YzJiIC8vIG1ldGhvZCAiYnV5U2hhcmVzKHVpbnQ2NCx1aW50OCx1aW50NjQscGF5KXZvaWQiCglwdXNoYnl0ZXMgMHhjNDIzOTBiNCAvLyBtZXRob2QgImVuZFByZWRpY3Rpb24odWludDY0LHVpbnQ4KXZvaWQiCglwdXNoYnl0ZXMgMHg1MTQ5NTNmMSAvLyBtZXRob2QgImNsYWltUmV3YXJkKHVpbnQ2NCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9hZGRQcmVkaWN0aW9uICphYmlfcm91dGVfYnV5U2hhcmVzICphYmlfcm91dGVfZW5kUHJlZGljdGlvbiAqYWJpX3JvdXRlX2NsYWltUmV3YXJkCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNhbGwgTm9PcAoJZXJyCgoqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudDoKCXByb3RvIDQgMwoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMSAvLyBlbGVtZW50Cgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCXJldHN1YgoKKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50OgoJcHJvdG8gNCAzCglmcmFtZV9kaWcgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0Cgljb25jYXQKCWZyYW1lX2J1cnkgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0xIC8vIGVsZW1lbnQKCWR1cAoJbGVuCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCWJ0b2kKCSsKCWl0b2IKCWV4dHJhY3QgNiAyCglmcmFtZV9idXJ5IC0yIC8vIGhlYWQgb2Zmc2V0CglmcmFtZV9kaWcgLTMgLy8gdHVwbGUgdGFpbAoJc3dhcAoJY29uY2F0CglmcmFtZV9idXJ5IC0zIC8vIHR1cGxlIHRhaWwKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0CglyZXRzdWI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "AlgoPredict",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "addPrediction",
        "args": [
          {
            "name": "question",
            "type": "string"
          },
          {
            "name": "option1Name",
            "type": "string"
          },
          {
            "name": "option2Name",
            "type": "string"
          },
          {
            "name": "startsAt",
            "type": "uint64"
          },
          {
            "name": "endsAt",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "buyShares",
        "args": [
          {
            "name": "predictionId",
            "type": "uint64"
          },
          {
            "name": "option",
            "type": "uint8"
          },
          {
            "name": "amount",
            "type": "uint64"
          },
          {
            "name": "payTxn",
            "type": "pay"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "endPrediction",
        "args": [
          {
            "name": "predictionId",
            "type": "uint64"
          },
          {
            "name": "result",
            "type": "uint8"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "claimReward",
        "args": [
          {
            "name": "predictionId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

export type IncludeSchema = {
  /**
   * Any overrides for the storage schema to request for the created app; by default the schema indicated by the app spec is used.
   */
  schema?: Partial<AppStorageSchema>
}

/**
 * Defines the types of available calls and state of the AlgoPredict smart contract.
 */
export type AlgoPredict = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication()void' | 'createApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'addPrediction(string,string,string,uint64,uint64)uint64' | 'addPrediction', {
      argsObj: {
        question: string
        option1Name: string
        option2Name: string
        startsAt: bigint | number
        endsAt: bigint | number
      }
      argsTuple: [question: string, option1Name: string, option2Name: string, startsAt: bigint | number, endsAt: bigint | number]
      returns: bigint
    }>
    & Record<'buyShares(uint64,uint8,uint64,pay)void' | 'buyShares', {
      argsObj: {
        predictionId: bigint | number
        option: number
        amount: bigint | number
        payTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [predictionId: bigint | number, option: number, amount: bigint | number, payTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'endPrediction(uint64,uint8)void' | 'endPrediction', {
      argsObj: {
        predictionId: bigint | number
        result: number
      }
      argsTuple: [predictionId: bigint | number, result: number]
      returns: void
    }>
    & Record<'claimReward(uint64)void' | 'claimReward', {
      argsObj: {
        predictionId: bigint | number
      }
      argsTuple: [predictionId: bigint | number]
      returns: void
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      predictionIndex?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type AlgoPredictSig = keyof AlgoPredict['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends AlgoPredictSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the AlgoPredict smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends AlgoPredictSig> = AlgoPredict['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the AlgoPredict smart contract to the method's return type
 */
export type MethodReturn<TSignature extends AlgoPredictSig> = AlgoPredict['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type AlgoPredictCreateCalls = (typeof AlgoPredictCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type AlgoPredictCreateCallParams =
  | (TypedCallParams<'createApplication()void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type AlgoPredictDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: AlgoPredictCreateCalls) => AlgoPredictCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class AlgoPredictCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the AlgoPredict smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the addPrediction(string,string,string,uint64,uint64)uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addPrediction(args: MethodArgs<'addPrediction(string,string,string,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addPrediction(string,string,string,uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.question, args.option1Name, args.option2Name, args.startsAt, args.endsAt],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the buyShares(uint64,uint8,uint64,pay)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static buyShares(args: MethodArgs<'buyShares(uint64,uint8,uint64,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'buyShares(uint64,uint8,uint64,pay)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.predictionId, args.option, args.amount, args.payTxn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the endPrediction(uint64,uint8)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static endPrediction(args: MethodArgs<'endPrediction(uint64,uint8)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'endPrediction(uint64,uint8)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.predictionId, args.result],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the claimReward(uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static claimReward(args: MethodArgs<'claimReward(uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'claimReward(uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.predictionId],
      ...params,
    }
  }
}

/**
 * A client to make calls to the AlgoPredict smart contract
 */
export class AlgoPredictClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `AlgoPredictClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof AlgoPredict['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the AlgoPredict smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: AlgoPredictDeployArgs & AppClientDeployCoreParams & IncludeSchema = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(AlgoPredictCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the AlgoPredict smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams & IncludeSchema & CoreAppCallArgs & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication()void'>, AppCreateCallTransactionResult>(await $this.appClient.create(AlgoPredictCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the AlgoPredict smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the addPrediction(string,string,string,uint64,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public addPrediction(args: MethodArgs<'addPrediction(string,string,string,uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(AlgoPredictCallFactory.addPrediction(args, params))
  }

  /**
   * Calls the buyShares(uint64,uint8,uint64,pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public buyShares(args: MethodArgs<'buyShares(uint64,uint8,uint64,pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(AlgoPredictCallFactory.buyShares(args, params))
  }

  /**
   * Calls the endPrediction(uint64,uint8)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public endPrediction(args: MethodArgs<'endPrediction(uint64,uint8)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(AlgoPredictCallFactory.endPrediction(args, params))
  }

  /**
   * Calls the claimReward(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public claimReward(args: MethodArgs<'claimReward(uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(AlgoPredictCallFactory.claimReward(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<AlgoPredict['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get predictionIndex() {
        return AlgoPredictClient.getIntegerState(state, 'predictionIndex')
      },
    }
  }

  public compose(): AlgoPredictComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      addPrediction(args: MethodArgs<'addPrediction(string,string,string,uint64,uint64)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addPrediction(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      buyShares(args: MethodArgs<'buyShares(uint64,uint8,uint64,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.buyShares(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      endPrediction(args: MethodArgs<'endPrediction(uint64,uint8)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.endPrediction(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      claimReward(args: MethodArgs<'claimReward(uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.claimReward(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as AlgoPredictComposer
  }
}
export type AlgoPredictComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the addPrediction(string,string,string,uint64,uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addPrediction(args: MethodArgs<'addPrediction(string,string,string,uint64,uint64)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): AlgoPredictComposer<[...TReturns, MethodReturn<'addPrediction(string,string,string,uint64,uint64)uint64'>]>

  /**
   * Calls the buyShares(uint64,uint8,uint64,pay)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  buyShares(args: MethodArgs<'buyShares(uint64,uint8,uint64,pay)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): AlgoPredictComposer<[...TReturns, MethodReturn<'buyShares(uint64,uint8,uint64,pay)void'>]>

  /**
   * Calls the endPrediction(uint64,uint8)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  endPrediction(args: MethodArgs<'endPrediction(uint64,uint8)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): AlgoPredictComposer<[...TReturns, MethodReturn<'endPrediction(uint64,uint8)void'>]>

  /**
   * Calls the claimReward(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  claimReward(args: MethodArgs<'claimReward(uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): AlgoPredictComposer<[...TReturns, MethodReturn<'claimReward(uint64)void'>]>

  /**
   * Makes a clear_state call to an existing instance of the AlgoPredict smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): AlgoPredictComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): AlgoPredictComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<AlgoPredictComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<AlgoPredictComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type AlgoPredictComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type AlgoPredictComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
